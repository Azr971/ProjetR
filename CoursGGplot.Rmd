---
title: "Visualisation de données avec R"
author: "par Jonathan EL METHNI"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = "center", 
                      warning = FALSE, 
                      message = FALSE)
```

Ce document présente un certain nombre de commandes concernant des packages **R** utiles pour faire de la visualisation de données. On commence tout d'abord par les installer puis par les charger :

```{r librairies}
library(ggplot2)       # Le package de référence pour faire de jolis graphiques
library(GGally)        # Un add-on au package ggplot2
library(tidyverse)     # Améliore certaines fonctionnalités de ggplot2
library(scales)        # Pour travailler avec différentes échelles
library(RColorBrewer)  # Pour avoir de jolies palettes de couleurs cohérentes
library(MASS)          # Pour travailler sur les données cats 
```

Le but de la visualisation de données étant de représenter graphiquement des données brutes (ou quasi-brutes), il est souvent nécessaire de prendre en compte plusieurs variables. Nous devons donc aller plus loin que les graphiques de base (nuage de points, droite de regression, boite à moustache, diagramme en barres ou circulaires, ...), pour les combiner par exemple.

Avec le langage de base (package `graphics` notamment), il est possible de faire des graphiques évolués, mais avec beaucoup de paramétrages *à la main*. Pour cela on va commencer par s'intéresser au jeu de données `mtcars`.

```{r mtcars}
head(mtcars)
# ?mtcars ou help(mtcars)
str(mtcars)
plot(mtcars$hp,mtcars$mpg)
```

Voici ici un exemple de graphique avancé, représentant 4 variables (trois quantitatives et une qualitative), ainsi qu'une explication succincte des différentes fonctions utilisées, et quelques paramètres de celles-ci.

```{r mtcars2}
par(family = "serif", mar = c(5, 4, 2, 0)+.1)
couleurs_am = brewer.pal(3, "Dark2")
plot(mpg ~ hp, 
     data = mtcars,
     pch = 19,
     cex = wt/3,
     col = couleurs_am[mtcars$am+1],
     main = "Consommation en fonction de la Puissance",
     sub = "Source : 1974 Motor Trend US magazine", font.sub = 3, cex.sub = .8,
     xlab = "Puissance (en ch)",
     ylab = "Consommation en Miles/Galon",
     bty = "n", axes = FALSE)
axis(1, lwd = 0, lwd.ticks = .5)
at.y = axis(2, lwd = 0, lwd.ticks = .5, labels = FALSE)
text(y = at.y, x = 35, labels = at.y, srt = 0, pos = 2, xpd = TRUE)
l1 = legend("topright", legend = c("Automatique", "Manuelle"), 
       col = couleurs_am, bty = "n", cex = .8, pch = 19,
       text.width = 50, text.col = couleurs_am, 
       title = "Boite de vitesse", title.col = "black")
legend(l1$rect$left, l1$rect$top-l1$rect$h-1, 
       legend = range(mtcars$wt), title = "Poids  (1000 lbs)",
       pch = 19, pt.cex = range(mtcars$wt)/3, bty = "n", cex = .8, col = gray(.5),
       text.width = 50, adj = -.25)
outliers_hp = subset(mtcars, subset = hp > 250)
text(outliers_hp$hp, outliers_hp$mpg, row.names(outliers_hp), pos = c(3, 2), cex = .8, font = 4)
outliers_mpg = subset(mtcars, subset = mpg > 30)
text(outliers_mpg$hp, outliers_mpg$mpg, row.names(outliers_mpg), pos = 4, cex = .8, font = 4)
```

- La fonction `par()` permet de modifier les paramètres graphiques, tel que :
    - `mar` pour les marges (un vecteur numérique de taille 4 qui permet de définir les tailles des marges dans l'ordre suivant : bas, gauche, haut, droite. Par défaut il vaut c(5.1, 4.1, 4.1, 2.1) )
    - `family` pour la famille de police d'écriture
    - certains paramètres ci-après sont définissables globalement dans la fonction `par()`, ou localement dans les fonctions suivantes
- Les paramètres de la fonction `plot()`
    - `pch` : symbole utilisé pour chaque point (ici `19` indique un rond plein)
    - `cex` : taille du point (ici en fonction de la variable `wt`)
    - `col` : couleur des points (ici en fonction de la variable  `am`)
    - `main`, `sub`, `xlab`, `ylab` : resp. titre, sous-titre, intitulé en abscisse et intitulé en ordonnée
    - `*.sub` : indication spécifique pour le sous-titre 
    - `bty` : type de la boite (ici `n` veut dire rien autour du graphique)
    - `axes` : présence ou non des axes (non ici)
- La fonction `axis()` qui permet d'ajouter un axe (`1` : en abscisse, et `2` : en ordonnée)
    - si rien d'indiqué pour `at`, utilisation des `ticks` par défaut
    - `lwd` : largeur de la ligne (ici non-présente)
    - `lwd.ticks` : largeur des ticks (assez fine ici)
    - renvoie les valeurs des ticks
- La fonction `text()` permet d'écrire du texte sur le graphique
    - le `x = 35` est choisi par expérience
    - `srt` : angle du texte
    - `pos` : ajustement du texte par rapport aux coordonnées indiquées
    - `xpd` : permet d'écrire en dehors du graphique (dans les marges donc)
- La fonction `legend()` permet d'ajouter une légende
    - position : soit $(x,y)$, soit chaine spécifique
    - `legend` : texte des items
    - `col`, `bty`, `cex`, `pch` : identique à précédemment
    - `text.width` et `text.col` : largeur du texte des items et couleur(s)
    - `title` et `title.col` : titre de la légende (et couleur du titre)
    - renvoie une liste avec deux objets (`rect` qui contient des infos sur le rectangle occupé par la légende dans le graphique et `text` qui contient les coordonnées du texte des items)
    - `pt.cex` : taille des symboles
    - `adj`: ajustement du texte
    
## Librairie `ggplot2`

Ce package reproduit la grammaire des graphiques (cf [*Grammar of Graphics*, Leland Wilkinson](http://www.springer.com/us/book/9780387245447)), avec le meme formalisme. Vous pouvez trouver plus d'informations sur le [site officiel](http://had.co.nz/ggplot2/) et la [documentation](http://docs.ggplot2.org/current/). Cet [article](http://www.tandfonline.com/doi/abs/10.1198/jcgs.2009.07098) permet de bien comprendre la philosophie du package et de la grammaire.

Le principe de cette grammaire est qu'un graphique est composé de couches :

- les **données** à représenter qui doivent etre dans un dataframe !!!
Si ce n'est pas le cas vous pouvez toujours le faire avec l'instruction `as.data.frame`.

- A partir de ces données nous allons définir des attributs **esthétiques** (soit identiques pour tous, soit fonction d'une des variables) :
    - les axes $x$ et $y$,
    - la couleur : `color`
    - la taille : `size`
    - la transparence : `alpha`
    - le remplissage : `fill`
    - la forme : `shape` 
- les attributs **géométriques** (point, droite, ...)
- les transformations **statistiques** (dénombrement, ajustement, ...)
- les **échelles**
- le système de **coordonnées** (linéaire, logarithmique, polaire, ...)
- le découpage (ou non) en **facettes**

Dans cette librairie, il y a deux fonctions principales :

- `qplot` (ou `quickplot`) permettant de faire des graphiques rapidement.
- `ggplot` permettant d'initialiser un graphique auquel on va ajouter des couches successives.

### Fonction `qplot()`

Traçons le meme nuage de points que précédemment.

```{r qplot1}
qplot(hp,mpg,data=mtcars)
```

On peut y ajouter des noms pour l'axes des abscisses et celui des ordonnées.

```{r qplot2}
p=qplot(hp,mpg,data=mtcars)
p+xlab("Puissance (en ch)")+ylab("Consommation en Miles/Galon")
```

Il est possible de distinguer par des couleurs les voitures disposant d'une boite manuelles de celles automatiques.

```{r qplot3}
qplot(hp,mpg,data=mtcars,colour = factor(am))
```

On peut mettre en avant la cylindrée des voitures (ici considérée comme une variable quantitative) par une échelle de couleur.

```{r qplot4}
qplot(hp,mpg, data = mtcars, colour = cyl)
```

Ou le faire par un nombre de couleurs correspondant au nombre de modalités de la variable `cyl` (ici considérée comme une variable qualitative).

```{r qplot5}
qplot(hp,mpg,data=mtcars,colour = factor(cyl))
```

Presque personne n'utilise la fonction `qplot` pour tracer un graphique car elle est plus difficile d'utilisation que `plot` et bien moins riche que la fonction à laquelle on va s'intéresser jusqu'à la fin du cours `ggplot`.

### Fonction `ggplot()`

La fonction `ggplot()` permet de faire plus de choses que `qplot()` mais nécessite un formalisme plus lourd, dont voici quelques détails :

- `ggplot()` crée un graphique (et le renvoie, i.e. on peut stocker un graphique dans une variable pour l'afficher plus tard, éventuellement en lui ajoutant des couches)
- `aes()` permet de définir les aspects esthétiques (`x` et `y` principalement, mais aussi `color`, `fill`, `size`, ...)
- `geom_xxx()` indique la représentation à choisir (`xxx` étant remplacé par `histogram`, `boxplot`, ...)
- `stat_xxx()` indique les transformations statistiques à utiliser, si besoin
- `scale_xxx()` s'emploie pour des changements d'échelle
- `coord_xxx()` s'utilise pour des modifications de systèmes de coordonnées
- `facet_xxx()` découpe les données (et donc le graphique) en plusieurs facettes selon les variables fournies dans la formule
- `theme_xxx()`, `labs()`, `xlab()`, `ylab()`, `ggtitle()`, ... pour des améliorations du graphique (annotations, couleurs, ...)

Hormis la fonction `aes()`, qui s'utilise à l'intérieur des autres, toutes ces fonctions peuvent s'additionner pour compléter le graphique.

Le fonctionnement de la fonction `ggplot()` est donc particulier, mais une fois compris, il est facile de créer chaque graphique statistique que l'on souhaite. 

On verra au long de ce document qu'il est possible de modifier le positionnement de certains éléments graphiques :

- `position="dodge"` : évite les chevauchements, place les éléments cote à cote
- `position="fill"` : empile les éléments qui se chevauchent , en normalisant pour avoir une hauteur égale
- `position="identity"` : n'ajuste pas la position
- `position="jitter"` : place les éléments cote en cote en essayant d'optimiser l'espace
- `position="stack"` : empile les éléments qui se chevauchent.

```{r fill}
ggplot(data=cats, aes(x=Sex)) + geom_bar(position="fill")
```

```{r stack}
ggplot(data=cats, aes(x=Sex)) + geom_bar(position="stack")
```

```{r dodge}
ggplot(data=cats, aes(x=Sex)) + geom_bar(position="dodge")
```


#### Fonctionnement général

La suite présente l'utilisation de différentes fonctions à travers des exemples concrets, afin de comprendre la philosophie de cette grammaire des graphiques.

Pour cela on va s'intéresser au jeu de données `diamonds` du package `ggplot2` :

```{r diamonds}
diamonds
# ?diamonds
str(diamonds)
```


#### Histogramme

Par exemple, pour décrire une variable continue par un histogramme, nous pouvons utiliser le code suivant :


```{r hist1}
ggplot(data = diamonds, aes(x = carat)) +geom_histogram()
```

Le premier paramètre de la fonction `ggplot()` est donc le dataframe sur lequel faire le graphique (ici `diamonds`). La fonction `aes()` permet de définir les aspects esthétiques (ici la variable `carat`). Cette fonction définit les paramètres globaux du graphique. Ensuite, nous appliquons une transformation géométrique, en calculant donc un histogramme (avec 30 intervalles par défaut), à l'aide de la fonction `geom_histogram()`. L'instruction `bins` permet de choisir le nombre d'intervalles.

```{r hist2}
ggplot(data = diamonds, aes(x = carat)) + geom_histogram(bins = 20)
```

L'instruction `binwidth` permet de modifier la base des rectangles formant l'histogramme.

```{r hist3}
ggplot(data = diamonds, aes(x = carat)) + geom_histogram(binwidth = 0.1)
```

Tous les histogrammes présentés précedemment le sont en terme d'effectif.
Il est possible de les représenter en terme de densité comme suit.

```{r hist4}
ggplot(data = diamonds, aes(x = carat)) + geom_histogram(aes(y=..density..),binwidth=0.1)
```

#### Stockage dans une variable

Un des gros intéret de la fonction `ggplot()` est le stockage du résultat dans une variable. Pour l'afficher, on peut soit appeler la variable, soit utiliser la fonction `print()` explicitement (voir ci-dessous). 

```{r hist5}
histo = ggplot(data = diamonds, aes(x = carat)) + geom_histogram()
histo # ou print(histo)
```

L'intéret sera de pouvoir créer des graphiques et les stocker dans un fichier `RData`, pour les afficher plus tard et/ou les modifier.

#### Personnalisation du graphique

##### Thème général

On peut améliorer le graphique de différentes manières. Tout d'abord, il existe différents thèmes généraux (cf `?theme_grey` - ou un autre - pour voir la liste). Voici le thème `classic` et le thème `light`:

```{r hist6}
histo + theme_classic()
histo + theme_light()
```

##### Plus d'options

Il existe beaucoup d'autres possibilités, avec la fonction `theme()` (pas d'exemple ici car complexe).

##### Labels

Une autre personnalisation courante est la redéfinition des labels des axes (et des légendes, comme nous le verrons plus tard), qui peut etre faite avec la fonction `labs()`.

```{r hist7}
histo + labs(x = "label en x", y = "label en y")
```

#### Boxplot

Si l'on veut tracer une boite à moustaches classique de la variable 
`carat` on utilise l'instruction suivante :

```{r boxplot1}
ggplot(data=diamonds,aes(x=factor(1),y=carat))+geom_boxplot()
```

Il est en effet beaucoup plus simple de tracer plusieurs boites à moustaches (fonction d'une variable) qu'une seule boite à moustache avec `ggplot`. Regardons ce qu'il se passe sur le jeu de données `cats`

```{r cats}
head(cats)
# ?cats
str(cats)
```

```{r boxplot2}
box = ggplot(data=cats, aes(x=Sex,y=Hwt))
box + geom_boxplot()
```

Par défaut les boites à moustaches sont dans le sens vertical mais il est très facile de les positionner à l'horizontale à l'aide de `coord_flip`

```{r boxplot3}
box + geom_boxplot() + coord_flip()
```

Il est possible de mettre en avant les outliers dans une autre couleur.

```{r boxplot4}
box + geom_boxplot(outlier.colour = "red", outlier.shape = 1)
```

On peut mettre en évidence tous les points en les superposant aux boites à moustaches et en utilisant `geom_jitter` pour les décaler. Attention à bien supprimer les outliers pour pas avoir de doublons.

```{r boxplot5}
box + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2)
```

On peut également changer la couleur à l'aide de la palette de couleurs déjà présente dans R. L'instruction `alpha` permet de spécifier la transparence.

```{r boxplot6}
box + geom_boxplot(fill="slateblue", alpha=0.2) +xlab("Sex")
```

On peut spécifier la couleur des boites à moustaches : contour et intérieur.

```{r boxplot7}
box + geom_boxplot(fill = "white", colour = "#3366FF")
```

Si l'on souhaite ne rien spécifier dans `geom_boxplot()` on peut conditionner les couleurs en fonction de la variable `Sex` à l'aide de l'instruction `fill` dans `ggplot`.

```{r boxplot8}
ggplot(data=cats, aes(x=Sex, y=Hwt, fill=Sex)) + geom_boxplot()
```

Afin d'avoir un graphique le plus sobre possible on supprime la légende.

```{r boxplot9}
ggplot(data=cats, aes(x=Sex, y=Hwt, fill=Sex)) + geom_boxplot() +theme(legend.position="none")
```

Il est un peu plus compliqué de rajouter la moyenne à chacun de nos boxplots.

```{r boxplot10}
ggplot(data=cats, aes(x=Sex, y=Hwt, fill=Sex)) +geom_boxplot(alpha=0.4) +stat_summary(fun.y=mean, geom="point", shape=20, size=5, color="red", fill="red") +theme(legend.position="none") + scale_fill_brewer(palette="Set3")
```


L'instruction `scale_fill_brewer` signifie : Sequential, diverging and qualitative colour scales from colorbrewer.org. Cette instruction permet de mettre des couleurs qui "vont bien ensemble" du package RColorBrewer. Voir http://colorbrewer2.org pour plus d'informations.


Il est possible de mettre des couleurs qui sont fonction des valeurs d'une variable qualitative ici `am`

```{r boxplot13}
ggplot(data = mtcars, aes(x=factor(cyl),y=hp,fill=factor(am)))+ geom_boxplot()
```

Revenons au jeu de données `diamonds` et traçons les boxplots de `price` en fonction de `carat` (variable quantitative ici coupée en classes).

```{r boxplot14}
ggplot(diamonds, aes(carat, price))+geom_boxplot(aes(group = cut_width(carat, 0.25)))
```

On peut jouer sur la transparence des outliers avec `outlier.alpha`.

```{r boxplot15}
ggplot(diamonds, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.25)), outlier.alpha = 0.1)
```

Ici on représente les boxplots de `carat` en fonction de `color` mais également de `cut`. On a plusieurs niveaux de lecture.

```{r boxplot16}
ggplot(diamonds, aes(x=color, y=carat, fill=cut)) + geom_boxplot() 
```


#### Barplot

Il est très simple de tracer un barplot ou diagramme en barres à l'aide de l'instruction `geom_bar()`

```{r barplot}
ggplot(data=cats, aes(x=Sex)) + geom_bar()
```

Calculer les effectifs en fonction de  `Sex` à l'aide de `table(Sex)`.

On peut réduire la largeur des batons avec `width`.

```{r barplot2}
ggplot(data=cats, aes(x=Sex)) + geom_bar(width=0.5)
```

Comme pour les boxplots il est possible de modifier les couleurs intérieures et extérieures.

```{r barplot3}
ggplot(data=mtcars, aes(x=as.factor(cyl)))+geom_bar(color="blue", fill=rgb(0.1,0.4,0.5,0.7) )
```

Ou les couleurs et cela en fonction de la variable qualitative `cyl`.
Toujours en utilisant l'instruction `scale_fill` :

- `scale_fill_manual()` : pour utiliser des couleurs personnalisées.
- `scale_fill_brewer()` : pour utiliser les palettes de couleurs du package RColorBrewer.
- `scale_fill_grey()` : pour utiliser la palette de couleurs grises.
- `scale_fill_hue()` : pour utiliser différentes teintes de couleurs.

```{r barplot3a}
ggplot(data=mtcars, aes(x=as.factor(cyl), fill=as.factor(cyl) )) + geom_bar( ) +scale_fill_hue(c = 40)
```

Si l'on veut obtenir une nuance de gris.

```{r barplot3b}
ggplot(data=mtcars, aes(x=as.factor(cyl), fill=as.factor(cyl) )) + geom_bar( ) +
  scale_fill_grey(start = 0.25, end = 0.75)
```

Si l'on souhaite utiliser la palette de R.

```{r barplot3c}
ggplot(data=mtcars, aes(x=as.factor(cyl), fill=as.factor(cyl) )) + geom_bar( ) +scale_fill_brewer(palette = "Set1")
```

Pour afficher les palettes dont dispose R.

```{r barplot3d}
display.brewer.all()
```

Si l'on souhaite utiliser la palette de R en spécifiant chaque couleur.

```{r barplot3e}
ggplot(data=mtcars, aes(x=as.factor(cyl), fill=as.factor(cyl) )) +  geom_bar( ) +
  scale_fill_manual(values = c("red", "green", "blue") )
```

Si l'on veut comparer la somme des valeurs de `mpg` selon les modalités de `cyl`.

```{r barplot4}
ggplot(data=mtcars, aes(x=factor(cyl), y=mpg)) + geom_bar(stat="identity")
```

Cela correspond à la somme de `mpg` dans les croisement `tapply(mtcars$mpg,mtcars$cyl,sum)`.

Si l'on veut comparer la somme des valeurs de `mpg` selon les modalités du croisement entre les variables `am` et `cyl` sous forme empilée. On parle de stacked bar.

```{r barplot5}
ggplot(data=mtcars, aes(fill=factor(am), y=mpg, x=factor(cyl)))+geom_bar(stat="identity")
```

Cela correspond à la somme de `mpg` dans les croisement `tapply(mtcars$mpg,list(mtcars$cyl,mtcars$am),sum)`.

En pourcentage à l'aide de `position="fill"`

```{r barplot6}
ggplot(data=mtcars, aes(fill=factor(am), y=mpg, x=factor(cyl))) +geom_bar(stat="identity",position="fill")
```

Si l'on souhaite utiliser la palette de R.

```{r barplot7}
ggplot(data=mtcars, aes(fill=factor(am), y=mpg, x=factor(cyl))) +geom_bar(stat="identity",position="fill")+scale_fill_brewer(palette = "Set1")
```


#### Aspect en fonction d'une variable

L'avantage de cette grammaire est de définir les paramètres du graphique en fonction des variables. Ceci est assez évident pour les coordonnées $x$ ou $y$, mais il est aussi possible de définir la couleur, la forme, la taille, ... en fonction de variables.

Ci-dessous, nous créons un diagramme en barres (avec  `geom_bar()`) sur une constante (`x = ""`). Cela a pour le moment peu d'intéret, sauf à montrer qu'il y a plus de 50000 diamants dans le jeu de données.

```{r bar1}
ggplot(diamonds, aes(x = "")) + geom_bar()
```

Dans le dataframe `diamonds`, nous disposons de la variable qualitative `cut`. Dans la suite, nous définissons une couleur en fonction de celle-ci (avec le paramètre esthétique `fill`). Ceci nous permet d'avoir un diagramme en barres empilées.

```{r bar2}
ggplot(diamonds, aes(x = "", fill = cut)) + geom_bar()
```

#### Variable spécifique (`..xxx..`)

Dans le diagramme ci-dessous est présenté le dénombrement de chaque modalité de la variable. Ceci peut ne pas etre particulièrement parlant, on peut préférer vouloir avoir des proportions (valeurs entre 0 et 1). C'est une bonne occasion pour utiliser les variables spécifiques créées par les fonctions de type `geom_xxx()`, qui sont de type `..xxx..`. Ici, `geom_bar()` créée la variable `..count..` qui représente le nombre de lignes pour chaque modalité. Donc, en redéfinissant les coordonnées $y$ avec le calcul $\frac{..count..}{\sum ..count..}$, nous réajustons les valeurs entre 0 et 1 (le graphique reste bien évidemment le meme finalement).

```{r bar3}
ggplot(diamonds, aes(x = "", fill = cut)) + 
    geom_bar(aes(y = ..count../sum(..count..)))
```

ou tout simplement avec l'instruction `position="fill"`.

```{r bar3bis}
ggplot(diamonds, aes(x = "", fill = cut)) + geom_bar(position="fill")
```

#### Changement d'échelle 

Maintenant que nous avons des valeurs entre 0 et 1, il peut etre intéressant de changer ces valeurs en pourcentage (entre 0 et 100 donc, et avec le sigle `%`). C'est possible avec ce qu'on va appeler un changement d'échelle, réalisable avec les fonctions de type `scale_xxx_yyy()` (où le `xxx` représente l'aspect esthétique à modifier et `yyy` le type de cet aspect). Dans notre cas, nous allons utiliser la fonction `percent()` du package `scales` pour afficher donc des valeurs en pourcentage, plutot qu'en proportion.

```{r bar4}
ggplot(diamonds, aes(x = "", fill = cut)) + 
    geom_bar(aes(y = (..count..)/sum(..count..))) +
    scale_y_continuous(labels = percent)
```

#### Changement de système de coordonnées

Pour continuer le tour des différentes possibilités de cette grammaire, nous allons créer maintenant un diagramme circulaire. Celui-ci peut etre vu comme un diagramme en barres empilées (comme ci-dessous), avec un changement de système de coordonnées. En effet, si on considère les données en coordonnées polaires, avec la variable $y$ définissant l'angle, nous obtenons ce que nous souhaitons. Ceci est réalisable avec les fonctions de type `coord_xxx()` (ici `coord_polar()` donc, en indiquant que l'angle `theta` dépend de $y$). Nous ajoutons l'option `width = 1` dans `geom_bar()` pour éviter d'avoir un trou au milieu du cercle.

```{r bar5}
ggplot(diamonds, aes(x = "", fill = cut)) + 
    geom_bar(aes(y = (..count..)/sum(..count..)), width = 1) +
    scale_y_continuous(labels = percent) +
    coord_polar(theta = "y")
```

Suite à ce qui a été vu précédemment, on peut donc avoir un graphique circulaire propre avec le code suivant.

```{r bar6}
ggplot(diamonds, aes(x = "", fill = cut)) + 
    geom_bar(aes(y = (..count..)/sum(..count..)), width = 1) +
    scale_fill_brewer(palette = "Set2") +
    scale_y_continuous(labels = percent) +
    coord_polar(theta = "y") +
    theme_minimal() +
    theme(axis.title = element_blank()) +
    labs(fill = "Variable cut")
```


#### Superposition de graphique (geom_point, geom_smooth)

Grace à la logique de construction des graphiques, via la grammaire, il est aisé de superposer différentes représentations, simplement en ajoutant les couches. Ci-dessous, nous dessinons le graphique entre les variables `hp` et `mpg`.


```{r plot1}
nuage=ggplot(data=cats, aes(x = Bwt, y =Hwt))
nuage
```


On peut dès lors rajouter le nuage de points à l'aide de `geom_point()`.

```{r plot2}
nuage+geom_point()
```

Si l'on veut décaler les points superposés.

```{r plot3}
nuage+geom_point(position="jitter")
```

Il est facile de changer la taille et la forme des points.

```{r plot4}
nuage+geom_point(size=2, shape=23)
```

Il est facile d'ajouter du texte sur un graphique avec `annotate()`.

```{r plot5}
nuage+geom_point()+annotate("text",x=2.5,y=15,label="blabla",colour="blue")
```

Il est facile à l'aide de `geom_rug` d'indiquer sur les axes les différentes valeurs prises par les variables.

```{r plot6}
nuage+geom_point()+geom_rug()
```

On peut très facilement y ajouter la droite des moindres carrés à l'aide de `geom_smooth`.

```{r plot7}
nuage+geom_point()+geom_rug()+geom_smooth(method = "lm", se = FALSE)
```

L'argument `se` de `geom_smooth` permet de faire apparaitre ou non les intervalles de confiance.

```{r plot8}
nuage+geom_point()+geom_point()+geom_rug()+geom_smooth(method = "lm", se = TRUE)
```

On peut effectuer un autre type d'ajustement qu'un ajustement linéaire qui fait apparaitre la tendance. C'est l'argument de base si on ne spécifie pas `method`.

```{r plot9}
nuage+geom_point()+geom_point()+geom_rug()+geom_smooth()
```

Il est possible de changer le type de points en fonction des niveaux de `Sex`

```{r plot10}
ggplot(data=cats, aes(x=Bwt, y=Hwt,shape=Sex))+geom_point()
```

Il est possible de changer le type de points ainsi que leur couleur en fonction des niveaux de `Sex`

```{r plot11}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex))+geom_point()
```

Il est possible de changer le type de points, leur couleur ainsi que leur taille en fonction des niveaux de `Sex`

```{r plot12}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex,size=Sex))+geom_point()
```

On peut y ajouter les différentes droites de régression dans les groupes formés par les modalités de `Sex`.

```{r plot13}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex)) +
  geom_point() + geom_smooth(method=lm,se=FALSE,)
```

Il est dès lors facile d'étendre les droites de régression.

```{r plot14}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex)) +
  geom_point() + geom_smooth(method=lm, se=FALSE, fullrange=TRUE)
```

Revenons au jeu de données `mtcars` car il est plus riche en variables.
On peut ainsi donner une taille aux points fonction d'une variable quantitative ici `qsec`.

```{r plot15}
nuage2=ggplot(data=mtcars, aes(x=hp,y=mpg))
nuage2+geom_point(aes(size=qsec))
```

On peut rajouter à chaque point le nom qui lui est attribué dans le dataframe
avec `geom_text()`. Cela peut etre vite illisible.

```{r plot16}
nuage2+geom_point()+geom_text(label=rownames(mtcars))
```

Avec `check_overlap` on peut faire en sorte que les noms ne se superposent pas.
`nudge_x` et `nudge_y` servent à ajuster la position du texte par rapport à celle des points.

```{r plot17}
nuage2+geom_point()+geom_text(label=rownames(mtcars), nudge_x = 0.25, nudge_y = 0.25, check_overlap = T)
```

Il peut etre préférable d'utiliser `geom_label()` au lieu de `geom_text`.

```{r plot18}
nuage2+geom_point()+geom_label(label=rownames(mtcars), nudge_x = 0.25, nudge_y = 0.2)
```

Avec un peu de couleur.

```{r plot19}
nuage2+geom_point()+geom_label(label=rownames(mtcars), color="blue", size=5)
```


 Ci-dessous, nous dessinons le nuage de points (via `geom_point()`) entre les variables `carat` et `price`. Nous ajoutons ensuite des indicateurs de valeurs sur chaque axe (avec `geom_rug()`), et la droite de régression (via `geom_smooth()` avec l'option `method = "lm"`).

```{r plot20}
ggplot(diamonds, aes(x = carat, y = price)) +geom_point() +geom_rug() +geom_smooth(method = "lm", se = FALSE)
```

#### Instructions supplémentaires 


Il est possible d'ajouter des lignes sur un graphique :

- `geom_vline()` : ligne verticale
- `geom_hline()` : ligne horizontale
- `geom_abline()` : ligne spécifiée par sa pente et son ordonnée à l'origine avec `intercept` et `slope`
- `geom_segment()`: segment (ou flèche en utlisant `arrow`).

```{r statdes}
summary(cats)
```

```{r plota}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex)) +
  geom_point()+geom_vline(xintercept=2.724)
```

```{r plotb}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex)) +
  geom_point()+geom_vline(xintercept=2.724)+geom_hline(yintercept = 10.63)
```

```{r plotc}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex)) +
  geom_point()+
   geom_curve(aes(x = 3.1, y = 10, xend = 3.7, yend = 11, colour = "curve")) +
 geom_segment(aes(x = 3.1, y = 10, xend = 3.7, yend = 11, colour = "segment"))


```

```{r ml}
summary(lm(cats$Hwt~cats$Bwt))
```

```{r plotd}
ggplot(data=cats, aes(x=Bwt, y=Hwt, color=Sex, shape=Sex)) +
  geom_point() + 
  geom_smooth(method=lm, se=FALSE, fullrange=TRUE)+
  geom_abline(intercept=-0.3567,slope=4.0341)
```

#### Faceting

Pour comparer des données, il est très intéressant de faire des graphiques de type [*small multiples*](http://www.juiceanalytics.com/writing/better-know-visualization-small-multiples). L'idée est de faire un meme graphique, mais pour chaque modalité d'une variable. Pour faire cela facilement avec `ggplot2`, nous disposons de deux fonctions : `facet_wrap()` et `facet_grid()`.

##### avec `facet_wrap()`

Cette première fonction permet de s'affranchir de la réflexion du nombre de modalités dans la variable en question. Le programme choisit lui-meme ce qu'il lui semble approprié. Ci-dessous, nous représentons le nuage de points entre `carat` et `price`, mais pour chaque valeur de `cut`.

```{r wrap}
ggplot(diamonds, aes(carat, price)) +
    geom_point() +
    facet_wrap(facets = ~ cut)
```

Si le choix ne convient pas, nous pouvons forcer le nombre de colonnes avec l'option `ncol` (ou le nombre de lignes avec `nrow`), comme ci-dessous.

```{r wrap2}
ggplot(diamonds, aes(carat, price)) +
    geom_point() +
    facet_wrap(facets = ~cut, ncol = 2)
```

Pour des boxplots au lieu de nuages de points.

```{r boxplot17}
ggplot(diamonds, aes(x=color, y=carat, fill=cut)) + geom_boxplot() +facet_wrap(~cut, scale="free")
```

Attention à l'échelle des ordonnées !

```{r boxplot18}
ggplot(diamonds, aes(x=color, y=carat, fill=cut)) + geom_boxplot() +facet_wrap(~cut)
```


Pour des diagrammes en barres, cela permet de comparer la somme des valeurs de `mpg` selon les modalités du croisement entre les variables `am` et `cyl`.

```{r barplot9}
ggplot(data=mtcars, aes(fill=factor(am), y=mpg, x=factor(cyl))) +geom_bar(stat="identity")+facet_wrap(~factor(am))
```


Cela correspond à la somme de `mpg` dans les croisement `tapply(mtcars$mpg,list(mtcars$cyl,mtcars$am),sum)`.



Pour des histogrammes.

```{r histo}
ggplot(data=diamonds, aes(x=carat, fill=cut)) + geom_histogram() +facet_wrap(~cut)
```

##### avec `facet_grid()`

Mais il est utile de forcer soit une répartition sur une meme ligne de ces différents graphiques, soit sur une meme colonne. Dans ce cas, nous utilisons la fonction `facet_grid()`, qui permet de déterminer explicitement comment on veut répartir les différentes facettes.

Ci-dessous, nous créons les boites à moustaches de `carat` pour chaque modalité de `color`, et ceci pour chaque modalité de `cut`. Tout est représenté sur une meme ligne.

```{r grid1}
ggplot(diamonds, aes(color, carat)) +
    geom_boxplot() +
    facet_grid(facets = ~ cut)
```

Pour forcer la répartition en colonne, nous inversons la formule. Ici, nous représentons l'histogramme de `carat`, pour chaque valeur de `cut` (cela permet donc de bien les comparer). Comme les effectifs ne sont pas les memes entre les modalités, nous décidons de laisser libre l'axe des $y$ pour mieux visualiser les répartitions, grace à l'option `scales`.

```{r grid2}
ggplot(diamonds, aes(x = carat)) +
    geom_histogram() +
    facet_grid(facets = cut ~ ., scales = "free_y")
```

De meme que précedemment on peut représenter les histogrammes (cette fois en densité) de la variable `depth` en fonction de `cut` à l'aide `facet_grid()`.

```{r grid3}
ggplot(diamonds, aes(x = depth)) +
    geom_histogram(aes(y=..density..),binwidth=0.1) +
    facet_grid(facets = cut ~ ., scales = "free_y")+xlim(58,68)
```

Bien évidemment, il est possible de combiner les deux possibilités. Par exemple, ici, nous créons le nuage de point entre `carat` et `price`, pour chaque couple de modalités des variables `color` et `cut`.

```{r grid4}
ggplot(diamonds, aes(carat, price)) +
    geom_point() +
    geom_smooth(method = "lm", fullrange = T) +
    facet_grid(facets = color ~ cut)
```

#### Graphiques de corrélation

Pour aller plus loin on peut utiliser le package `GGally` qui est une extension de `ggplot2. Commençons par extraire les données quantitatives du jeu de données `mtcars`.

```{r correlation}
mtcarsquant <- mtcars[, c(1,3,4,5,6,7)]
head (mtcarsquant)
```

A partir de ce nouveau jeu de données on peut obtenir le graphique ci-dessous qui met en avant les corrélations 2 à 2 à l'aide d'une échelle de couleurs.

```{r correlation2}
ggcorr(mtcarsquant, palette = "RdBu", label = TRUE)
```

On peut enrichir ces résultats à l'aide du graphique ci-après qui nous renseigne en plus sur la densité des variables et les nuages de points correspondant au croisement des variables 2 à 2 et donc aux coefficients de corrélation.

```{r correlation3}
ggpairs(mtcarsquant)
```

#### Effet du placement de data et aes()

Dans le graphique ci-dessous, nous ne redéfinissons jamais `x` ou  `y`. Ceux-ci ayant été définis dans la fonction `ggplot()`, les fonctions ajoutées reprennent leur définition. Mais il est possible de les définir dans chaque fonction.

Pour détailler ce comportement, voici trois commandes permettant de faire strictement le meme graphique (le premier produit dans le paragraphe ci-dessous).

```{r placement, eval=FALSE}
ggplot(diamonds, aes(x = price)) + geom_histogram()
ggplot(diamonds) + geom_histogram(mapping = aes(x = price))
ggplot() + geom_histogram(data = diamonds, mapping = aes(x = price))
```

Voici ce qui diffère entre ces trois versions :

- Dans la première, les données seront `diamonds` pour l'ensemble des commandes ajoutées, et $x$ sera la variable `price` (sauf spécification ultérieure) ;
- Dans la seconde, on utilisera toujours `diamonds` comme données, mais $x$ n'est défini que pour l'histogramme. On devra définir $x$ pour les fonctions ultérieures si besoin ;
- Dans la dernière, il n'y aucune spécification de base, et chaque fonction devra déterminée quelles données prendre, ainsi que les aspects esthétiques à utiliser dans celles-ci.

Ce mécanisme est particulièrement intéressant lorsque nous souhaitons utiliser plusieurs jeux de données ensemble. Dans le graphique ci-dessous, nous allons afficher trois informations différentes :

- les différentes valeurs de `price` en fonction de la variable `cut`, avec un aléa sur l'axe des $x$ (avec la fonction `geom_jitter()`) ;
- les boites à moustaches ;
- un indicateur de moyenne (avec la fonction `geom_point()`) et d'écart-type (avec `geom_errorbar()`). 

Pour cela, nous calculons en premier lieu la moyenne et l'écart-type de `price` pour chaque modalité de `cut`, stocké dans `df`.

```{r df}
df = diamonds %>%
    group_by(cut) %>%
    summarise(
        mean = mean(price, na.rm = T),
        sd = sd(price, na.rm = T)
    )
```

```{r kable, echo=FALSE}
knitr::kable(df)
```

Nous avons donc le graphique ci-dessous, produit par un code très complet.

```{r multipledf}
ggplot(data = diamonds, aes(x = cut, y = price, color = cut)) +
    scale_color_brewer(palette = "Set2") +
    scale_fill_brewer(palette = "Set2") +
    geom_jitter(alpha = .1) +
    geom_boxplot(mapping = aes(fill = cut), 
                 color = "gray40", width = .5,
                 outlier.color = "gray70") +
    geom_errorbar(data = df, 
                  mapping = aes(y = mean, 
                                ymin = mean - sd, 
                                ymax = mean + sd), 
                  col = "steelblue", width = .4, size = 1) +
    geom_point(data = df, 
               mapping = aes(y = mean), 
               col = "steelblue", size = 2) +
    theme_classic()
```

#### Enregistrer un graphique

Afin d'enregistrer un graphique réalisé avec `ggplot()` on utilise `ggsave()`.

- `filename` : nom du fichier, ou chemin et nom du fichier
- `plot` : graphique à sauvegarder (par défaut, le dernier)
- `scale` : facteur d'échelle
- `width` : largeur
- `height` : hauteur
- `dpi` : nombre de points par pouce, uniquement pour les images matricielles

`ggsave()` reconnait automatiquement les extensions suivantes :

- `eps/ps`
- `pdf`
- `jpeg`
- `tiff`
- `png`
- `bmp`
- `svg`

#### Exemple version `ggplot`

Nous pouvons maintenant reprendre le graphique fait au début, pour le recréer avec la fonction `ggplot()`. Ici, tout est automatisé (couleur, légende, labels) et le code sera beaucoup plus robuste à de nouvelles données.

```{r amelioration}
ggplot(mtcars %>% rownames_to_column(), 
       aes(x = hp, y = mpg, 
           color = factor(am, labels = c("Automatique", "Manuelle")), 
           size = wt, 
           label = ifelse(hp <= 250 & mpg <=30, "", rowname))) + 
  geom_point() + 
  geom_text(size = 3, color = "black",
            vjust = -.75, fontface = "bold",
            hjust="inward") +
  ggtitle("Consommation en fonction de la Puissance") +
  labs(x = "Puissance (en ch)", 
       y = "Consommation en Miles/Galon",
       color = "Transmission", 
       size = "Poids (1000 lbs)") +
  theme_classic()
```

Vous pouvez maintenant le stocker et l'enregistrer !

### Package Esquisse

https://cran.r-project.org/web/packages/esquisse/vignettes/get-started.html


### Retour sur quelques graphiques historiques

```{r librairies2}
# Package contenant des jeux de données sur l'histoire de la statistique et de la data visualisation
library(HistData) 
library(Guerry)  # spécifique au jeu de données Guerry
```

### William Playfair (1759-1823)

```{r playfair originale, echo=FALSE, fig.cap="Le graphique original de William Playfair (1759-1823)", out.width = '100%'}
knitr::include_graphics("Playfair.png")
```


```{r playfair,echo=TRUE}
data(Wheat)
fillpoly <- function(x,y, low=min(y),  ...) {
    n <- length(x)
    polygon( c(x, x[n], x[1]), c(y, low, low), ...)
}
with(Wheat, {
    plot(Year, Wheat, type="s", ylim=c(0,105), 
        ylab="Price of the Quarter of Wheat (shillings)", 
        panel.first=grid(col=gray(.9), lty=1))
    fillpoly(Year, Wages, low=0, col="lightskyblue", border=NA)
    lines(Year, Wages, lwd=3, col="red")
    })
text(1625,10, "Weekly wages of a good mechanic", cex=0.8, srt=3, col="red")
text(1650, 85, "Chart", cex=2, font=2)
text(1650, 70, 
  paste("Shewing at One View", 
        "The Price of the Quarter of Wheat", 
        "& Wages of Labor by the Week", 
        "from the Year 1565 to 1821",
        "by William Playfair",
        sep="\n"), font=3)
with(Wheat.monarchs, {
	y <- ifelse( !commonwealth & (!seq_along(start) %% 2), 102, 104)
	segments(start, y, end, y, col="black", lwd=7, lend=1)
	segments(start, y, end, y, col=ifelse(commonwealth, "white", NA), lwd=4, lend=1)
	text((start+end)/2, y-2, name, cex=0.5)
	})
```

```{r playfair2,echo=TRUE}
Wheat1 <- within(na.omit(Wheat), {Labor=Wheat/Wages})
with(Wheat1, {
  plot(Year, Labor, type='b', pch=16, cex=1.5, lwd=1.5, 
	     ylab="Labor cost of a Quarter of Wheat (weeks)",
	     ylim=c(1,12.5));
	lines(lowess(Year, Labor), col="red", lwd=2)
	})
text(1740, 10, "Chart", cex=2, font=2)
text(1740, 8.5, 
	paste("Shewing at One View", 
        "The Work Required to Purchase", 
        "One Quarter of Wheat", 
        sep="\n"), cex=1.5, font=3)
with(Wheat.monarchs, {
	y <- ifelse( !commonwealth & (!seq_along(start) %% 2), 12.3, 12.5)
	segments(start, y, end, y, col="black", lwd=7, lend=1)
	segments(start, y, end, y, col=ifelse(commonwealth, "white", NA), lwd=4, lend=1)
	text((start+end)/2, y-0.2, name, cex=0.5)
	})
```

### André-Michel Guerry (1802-1866)

```{r guerry originale, echo=FALSE, fig.cap="Le graphique original de André-Michel Guerry (1802-1866)", out.width = '100%'}
knitr::include_graphics("Guerry.jpg")
```


```{r guerry,echo=TRUE}
require(sp)
data(gfrance)
plot(gfrance)
```


```{r guerry2,echo=TRUE}
spplot(gfrance, "Crime_pers")
```


```{r guerry3,echo=TRUE}
spplot(gfrance, "Crime_prop")
```

```{r guerry4,echo=TRUE}
spplot(gfrance, "Literacy")
```

```{r guerry5,echo=TRUE}
local({
  gfrance$Crime_pers <- rank(gfrance$Crime_pers)
  gfrance$Crime_prop <- rank(gfrance$Crime_prop)
  gfrance$Literacy <- rank(gfrance$Literacy)
  gfrance$Donations <- rank(gfrance$Donations)
  gfrance$Infants <- rank(gfrance$Infants)
  gfrance$Suicides <- rank(gfrance$Suicides)
  spplot(gfrance, c("Crime_pers", "Crime_prop", "Literacy", "Donations", "Infants", "Suicides"), 
    layout=c(3,2), as.table=TRUE, main="Guerry's main moral variables")
}) 
```


### Florence Nightingale (1820-1910)

```{r nightingale originale, echo=FALSE, fig.cap="Le graphique original de ", out.width = '100%'}
knitr::include_graphics("Nightingale.jpg")
```


```{r nightingale,echo=TRUE}
data(Nightingale)
require(reshape)
Night<- Nightingale[,c(1,8:10)]
melted <- melt(Night, "Date")
names(melted) <- c("Date", "Cause", "Deaths")
melted$Cause <- sub("\\.rate", "", melted$Cause)
melted$Regime <- ordered( rep(c(rep('Before', 12), rep('After', 12)), 3), 
                          levels=c('Before', 'After'))
Night <- melted
Night1 <- subset(Night, Date < as.Date("1855-04-01"))
Night2 <- subset(Night, Date >= as.Date("1855-04-01"))
Night1 <- Night1[order(Night1$Deaths, decreasing=TRUE),]
Night2 <- Night2[order(Night2$Deaths, decreasing=TRUE),]
Night <- rbind(Night1, Night2)
cxc1 <- ggplot(Night1, aes(x = factor(Date), y=Deaths, fill = Cause)) +
  	# do it as a stacked bar chart first
   geom_bar(width = 1, position="identity", stat="identity", color="black") +
		# set scale so area ~ Deaths	
   scale_y_sqrt() 
		# A coxcomb plot = bar chart + polar coordinates
cxc1 + coord_polar(start=3*pi/2) + 
	ggtitle("Causes of Mortality in the Army in the East") + 
	xlab("")
```


```{r nightingale2,echo=TRUE}
cxc2 <- ggplot(Night2, aes(x = factor(Date), y=Deaths, fill = Cause)) +
   geom_bar(width = 1, position="identity", stat="identity", color="black") +
   scale_y_sqrt()
cxc2 + coord_polar(start=3*pi/2) +
	ggtitle("Causes of Mortality in the Army in the East") + 
	xlab("")
```


```{r nightingale3,echo=TRUE}
colors <- c("blue", "red", "black")
with(Nightingale, {
  plot(Date, Disease.rate, type="n", cex.lab=1.25, 
		ylab="Annual Death Rate", xlab="Date", xaxt="n",
		main="Causes of Mortality of the British Army in the East");
	# background, to separate before, after
	rect(as.Date("1854/4/1"), -10, as.Date("1855/3/1"), 
		1.02*max(Disease.rate), col=gray(.90), border="transparent");
	text( as.Date("1854/4/1"), .98*max(Disease.rate), "Before Sanitary\nCommission", pos=4);
	text( as.Date("1855/4/1"), .98*max(Disease.rate), "After Sanitary\nCommission", pos=4);
	# plot the data
	points(Date, Disease.rate, type="b", col=colors[1], lwd=3);
	points(Date, Wounds.rate, type="b", col=colors[2], lwd=2);
	points(Date, Other.rate, type="b", col=colors[3], lwd=2)
	}
)
# add custom Date axis and legend
axis.Date(1, at=seq(as.Date("1854/4/1"), as.Date("1856/3/1"), "3 months"), format="%b %Y")
legend(as.Date("1855/10/20"), 700, c("Preventable disease", "Wounds and injuries", "Other"),
	col=colors, fill=colors, title="Cause", cex=1.25)
```

```{r nightingale4,echo=TRUE}
Nightingale <- within(Nightingale, {
  Total <- Disease + Wounds + Other
	Disease.pct <- 100*Disease/Total
	Wounds.pct <- 100*Wounds/Total
	Other.pct <- 100*Other/Total
	})
colors <- c("blue", "red", "black")
with(Nightingale, {
	plot(Date, Disease.pct, type="n",  ylim=c(0,100), cex.lab=1.25,
		ylab="Percent deaths", xlab="Date", xaxt="n",
		main="Percentage of Deaths by Cause");
	rect(as.Date("1854/4/1"), -10, as.Date("1855/3/1"), 
		1.02*max(Disease.rate), col=gray(.90), border="transparent");
	text( as.Date("1854/4/1"), .98*max(Disease.pct), "Before Sanitary\nCommission", pos=4);
	text( as.Date("1855/4/1"), .98*max(Disease.pct), "After Sanitary\nCommission", pos=4);
	# plot the data
	points(Date, Disease.pct, type="b", col=colors[1], lwd=3);
	points(Date, Wounds.pct, type="b", col=colors[2], lwd=2);
	points(Date, Other.pct, type="b", col=colors[3], lwd=2)
	}
)
axis.Date(1, at=seq(as.Date("1854/4/1"), as.Date("1856/3/1"), "3 months"), format="%b %Y")
legend(as.Date("1854/8/20"), 60, c("Preventable disease", "Wounds and injuries", "Other"),
	col=colors, fill=colors, title="Cause", cex=1.25)
```


### John Snow (1813-1858)

```{r snow originale, echo=FALSE, fig.cap="Le graphique original de John Snow (1813-1858)", out.width = '100%'}
knitr::include_graphics("Snow.jpg")
```


```{r snow,echo=TRUE}
SnowMap(xlim = c(3, 20), ylim = c(3, 20), 
        axis.labels = FALSE, main = "Snow's Cholera Map of London", 
        scale = TRUE, polygons = FALSE, density=FALSE,
        streets.args = list(col = "grey", lwd = 1), 
        deaths.args = list(col = "red", pch = 15, cex = 0.6), 
        pumps.args = list(col = "blue", pch = 17, cex = 1.5, cex.lab = 0.9), 
        scale.args = list(xs = 3.5, ys = 19.7), 
        polygons.args = list(col=NA, border="brown", lwd=2, lty=1),
        density.args=list(bandwidth=c(0.5,0.5), 
                  col1=rgb(0,1,0,0),
                  col2=rgb(1,0,0,.8))
)
```


```{r snow4,echo=TRUE}
require(lubridate)
clr <- ifelse(Snow.dates$date < mdy("09/08/1854"), "red", "darkgreen")
plot(deaths ~ date, data=Snow.dates, type="h", lwd=2, col=clr)
points(deaths ~ date, data=Snow.dates, cex=0.5, pch=16, col=clr)
text( mdy("09/08/1854"), 40, "Pump handle\nremoved Sept. 8", pos=4)
```


### Charles Joseph Minard (1781-1870)

```{r minard originale, echo=FALSE, fig.cap="Le graphique original de Charles Joseph Minard (1781-1870)", out.width = '100%'}
knitr::include_graphics("Minard.jpg")
```

```{r minard,echo=TRUE}
data(Minard.troops)
data(Minard.cities)
data(Minard.temp)
require(gridExtra)
 plot_troops <- ggplot(Minard.troops, aes(long, lat)) +
  	geom_path(aes(size = survivors, colour = direction, group = group),
                 lineend = "round", linejoin = "round")
 plot_cities <- geom_text(aes(label = city), size = 4, data = Minard.cities)
breaks <- c(1, 2, 3) * 10^5 
plot_minard <- plot_troops + plot_cities +
 	scale_size("Survivors", range = c(1, 10), 
 	            breaks = breaks, labels = scales::comma(breaks)) +
  scale_color_manual("Direction", 
                     values = c("grey50", "red"), 
                     labels=c("Advance", "Retreat")) +
  coord_cartesian(xlim = c(24, 38)) +
  xlab(NULL) + 
  ylab("Latitude") + 
  ggtitle("Napoleon's March on Moscow") +
  theme_bw() +
  theme(legend.position=c(.8, .2), legend.box="horizontal")
plot_temp <- ggplot(Minard.temp, aes(long, temp)) +
	geom_path(color="grey", size=1.5) +
	geom_point(size=2) +
	geom_text(aes(label=date)) +
	xlab("Longitude") + ylab("Temperature") +
	coord_cartesian(xlim = c(24, 38)) + 
	theme_bw()
grid.arrange(plot_minard, plot_temp, nrow=2, heights=c(3,1))
```

```{r minard revisitée, echo=FALSE, fig.cap="Le graphique revisitée de Charles Joseph Minard (1781-1870)", out.width = '100%'}
knitr::include_graphics("Minard.png")
```

https://www.yvesago.net/pourquoi/2014/03/r-la-campagne-de-russie-par-minard.html


### Un peu de cartographie : 

Un des aspects intéressant dans la visualisation de données est la représentation de cartes, soit avec des marqueurs locaux (i.e. des points représentant des positions géographiques, avec des attributs esthétiques dépendant d'une variable par exemple), soit avec des *couches* représentant des zones spécifiques (pays, région, ville, avec une couleur dépendant d'une variable aussi).

```{r, echo=TRUE}
library(maps)
library(tibble)
library(leaflet)
```

### Avec la librairie `leaflet`

La librairie [`leaflet`](https://rstudio.github.io/leaflet/) permet de créer des cartes dans R à partir de la librairie Javascript [Leaflet](http://leafletjs.com/).

Voici un premier exemple simple de création de carte du monde

```{r leaflet-carte}
m = leaflet() %>% addTiles()
m
```

Pour laquelle il est possible de choisir la zone d'intérêt, en indiquant les latitudes et longitudes min et max.

```{r leaflet-bounds}
m %>% fitBounds(0, 40, 5, 50)
```

Il est aussi possible de préciser les coordonnées géographiques du centre de la carte, ainsi que le niveau de zoom (entre 1 - monde - et 18 - pâté de maison).

```{r leaflet-setView}
m = m %>% setView(2.268224, 48.842275, zoom = 17)
m
```

On peut y ajouter une *pop-up* assez facilement.

```{r leaflet-popup}
m %>% addPopups(2.268224, 48.842275, "IUT Paris Descartes")
```

Ou un marqueur, pour lequel le texte s'affichera lorsque nous cliquerons sur le marqueur.

```{r leaflet-marker}
m %>% addMarkers(2.268224, 48.842275, popup = "IUT Paris Descartes")
```

Voire des formes classiques (cercle, rectangle, polygone)

```{r leaflet-forme}
m %>% addCircles(2.268224, 48.842275, radius = 100) %>% 
    addRectangles(2.27, 48.835, 2.28, 48.84)
```

A partir du jeu de données `ozone` du package `maps`, et contenant des informations géographiques, nous allons représenter ces informations sur une carte.

```{r leaflet-position-data}
DT::datatable(head(ozone))
```

Ici, nous faisons en sorte que la taille des cercles soient dépendantes de la variable `median`, mais nous devons ajuster *à la main* pour avoir des valeurs intéressantes pour la représentation.

```{r leaflet-position-circles}
leaflet(ozone) %>% addTiles() %>% 
    addCircles(lng = ~x, lat = ~y, radius = ~median*100)
```




## Les cartes choroplèthes

Une carte choroplèthe est une carte géographique avec des zones ayant une couleur dépendant d’une mesure statistique pour cette zone. Nous allons utiliser le package leaflet pour voir comment en produire une.

Nous commençons par charger les données géographiques, provenant d’un open data, grâce à la `fonction geojson_read()` du package *geojsonio*.

```{r, echo=TRUE}
library(geojsonio)
library(precrec)
library(dplyr)
```


```{r, echo=TRUE}
# Lecture des données spatiales
json_file <- 'https://datahub.io/core/geo-countries/r/countries.geojson'
etats = geojson_read(json_file, what = "sp")
```

Dans la variable `etats`, il y a une table avec les noms des pays et le code ISO associé. C’est cette table qui nous permettra par la suite de mettre une couleur en fonction d’une mesure statistique plus tard (en réalisant une jointure).

```{r, echo=TRUE}
head(etats@data)
```

Pour affecter une couleur en fonction d’une variable, nous décidons de tirer ici des valeurs issues d’une variable aléatoire uniforme entre 0 et 1.

```{r, echo=TRUE}
# Création d'une variable aléatoire pour tester
etats@data$var = runif(nrow(etats@data))
```

# Graphique

A partir de ces données, nous allons pouvoir représenter les pays sur un graphique avec la fonction `ggplot()`. Pour cela, nous allons devoir modifier la structure des données, avec la fonction `fortify()`.

```{r, echo=TRUE}
etats_f = fortify(etats)
```

Ensuite, nous pouvons donc créer une représentation graphique des pays.

```{r, echo=TRUE}
ggplot(etats_f, aes(long, lat, group = group)) +
  geom_polygon(color = "white") +
  theme_void()
```

Puisque nous avons une variable, nous pouvons choisir de colorer les pays en fonction de celle-ci automatiquement.

```{r, echo=TRUE}
etats_fj = etats_f %>%
  inner_join(etats@data %>% rownames_to_column("id"), by = "id")
ggplot(etats_fj, aes(long, lat, group = group, fill = var)) +
  geom_polygon(color = "white") +
  theme_void()
```

# Carte
Pour créer une carte, on doit réaliser au minimum deux étapes :

la création d’un objet de type carte, avec la fonction `leaflet()`
l’ajout de tuiles (fond de carte) avec la fonction `addTiles()`.
Il existe différentes tuiles disponibles, que vous pouvez tester ici

Ensuite, puisque nous souhaitons des polygones basés sur un jeu de données déjà insérée dans la carte (lors de la création), nous ajoutons la fonction `addPolygons()`. Une fois la carte créée et stockée dans une variable, celle-ci doit être affichée.

```{r, echo=TRUE}
# Création de la carte avec un polygone par pays
carte = leaflet(etats) %>% 
  addTiles() %>%
  addPolygons()

# Affichage de la carte
carte
```


Grâce à la fonction `colorBin()`, nous créons une palette qui permettra d’associer une valeur à une couleur (ici, entre jaune et rouge, puisqu’on a choisi *"YlOrRd"* - il existe d’autres palettes possibles issues de color brewer ou viridis). Enfin, dans la création de la carte, on indique que la couleur de remplissage est fonction de la palette et de la variable créée.


```{r, echo=TRUE}
# Création d'une palette affectant une couleur en fonction d'une variable
palette = colorBin("YlOrRd", domain = etats$var)

# Création de la carte choroplèthe
carte2 = leaflet(etats) %>% 
  addTiles() %>%
  addPolygons(fillColor = ~palette(var), fillOpacity = .5)
# Affichage de la carte
carte2
```

On peut améliorer cette carte en définissant la vue souhaitée (ici, on définit le point central et le niveau de zoom). On spécifie aussi la couleur, la taille et le type de ligne pour les contours des polygones. Enfin, on ajoute une légende permettant de savoir à quelle valeur correspond chaque couleur. Pour cela, nous devons spécifier les intervalles lors de la création de la palette.

```{r, echo=TRUE}
# Amélioration de la carte choroplèthe
palette = colorBin(
  "magma", 
  domain = etats$var, 
  bins = seq(0, 1, by = .2))

carte3 = leaflet(etats) %>% 
  setView(lat = 0, lng = 0, zoom = 1) %>%
  addTiles() %>%
  addPolygons(
    fillColor = ~palette(var), fillOpacity = .5,
    color = "gray30", weight = 1.5, opacity = 1, dashArray = "2"
  ) %>%
  addLegend(
    pal = palette, 
    values = ~var, 
    opacity = 0.8, 
    title = "Variable aléatoire",
    position = "bottomright"
  )
# Affichage de la carte
carte3
```

## Airbnb

Nous disposons de données d'AirBnB pour Paris à la date du 2 septembre 2015 ( [données source](http://insideairbnb.com/get-the-data.html) ). Celles-ci ont été légèrement nettoyées et réduites pour obtenir les fichiers suivants :

| Fichier | Contenu |
|:-|:-|
`airbnb-paris-2015-09-02-summary.csv           `| Résumé de quelques informations de base |
`airbnb-paris-2015-09-02.csv                   `| Données plus complètes |
`airbnb-paris-2015-09-02-neighbourhoods.geojson`| Représentation graphiques des arrondissements |

On commence déjà par importer ces données dans R.

```{r, echo=TRUE}
airbnb.summ <- read.csv("~/Documents/Elmethni/Boulot/IUT/DUDataViz/Cours/4VisualisationAvecR/Cours Données/VisualisationAvecR/Cours/airbnb-paris-2015-09-02-summary.csv")

airbnb.comp <- read.csv("~/Documents/Elmethni/Boulot/IUT/DUDataViz/Cours/4VisualisationAvecR/Cours Données/VisualisationAvecR/Cours/airbnb-paris-2015-09-02.csv")
```

Sur ces données, il est déjà possible de représenter chaque logement par un point, assez simplement

```{r airbnb-point}
ggplot(airbnb.summ, aes(x=longitude, y=latitude)) + geom_point()
```

La librairie [`geojsonio`](https://github.com/ropensci/geojsonio) permet de lire et d'écrire des données au format [GeoJSON](http://geojson.org/geojson-spec.html), permettant de représenter des objets géographiques dans un formalisme issue de `JSON`. Il est très utilisé pour représenter des zones, telles que des villes, des pays, ... 

On importe donc les données des arrondissements. La fonction `fortify()` de `ggplot2` nous permet ici de passer à un format lisible pour `ggplot()`.


```{r airbnb-geo}
airbnb.neigh = geojson_read("http://fxjollois.github.io/donnees/airBnB-2015-09-02/airbnb-paris-2015-09-02-neighbourhoods.geojson", what = "sp")
airbnb.neigh.for = fortify(airbnb.neigh)
ggplot(airbnb.neigh.for, aes(long, lat, group=group)) +
    geom_polygon(color = "white")  + theme_void()
```

Le problème dans notre cas est que les quartiers ne sont pas classés dans un ordre spécifique dans les données, et que l'objet `airbnb.neigh` ne comporte plus le nom du quartier, ce qui va nous empêcher de faire le lien avec les autres données. Le code suivant permet donc de récupérer l'ordre des quartiers et de le stocker dans un `data.frame`. On lit différemment le jeu de données.

```{r airbnb-order}
df = geojson_read("http://fxjollois.github.io/donnees/airBnB-2015-09-02/airbnb-paris-2015-09-02-neighbourhoods.geojson")
airbnb.neigh.ord = data.frame(
    id = as.character(1:20),
    neighbourhood = sapply(df$features, function(f) return(f$properties$neighbourhood))
)
airbnb.neigh.ord
```

Il peut être intéressant de calculer le centre de chaque quartier, pour pouvoir l'ajouter sur la carte par la suite. Pour cela, nous prenons la moyenne entre la latitude (et resp. la longitude) minimale et maximale.

```{r airbnb-center}
airbnb.neigh.cen = airbnb.neigh.for %>% 
  group_by(id) %>% 
  summarise(
    long = mean(range(long, na.rm = T)),
    lat = mean(range(lat, na.rm = T))
  ) %>%
  inner_join(airbnb.neigh.ord)
ggplot(airbnb.neigh.for, aes(long, lat, group=group)) +
    geom_polygon(fill = "gray70", color = "gray50") +
    geom_text(data = airbnb.neigh.cen, aes(label = neighbourhood, group=id)) + theme_void()
```

Au final, on peut faire une carte des arrondissements, en y ajoutant le nom du voisinage, les points des logements et une couleur pour chaque arrondissement dépendant de la variable `group` par exemple (on pourra utiliser ce schéma pour représenter des informations statistiques par exemple)

```{r airbnb-tout}
ggplot(airbnb.neigh.for) +
    geom_polygon(aes(long, lat, group=group, fill=id), color="gray50") +
    geom_point(data=airbnb.summ, aes(longitude, latitude), col="gray30", alpha=.25) +
    geom_text(data=airbnb.neigh.cen, aes(long, lat, label=neighbourhood, group=id)) + 
    theme_void() + theme(legend.position="none")
```

<!-- ### 3. Représenter ces deux informations sur la carte de Paris, avec pour la première -->

<!-- - soit du point par point -->
<!-- - soit avec une *heatmap* -->

<!-- library("ggmap") -->
<!-- m <- c(left = 2.25, bottom = 48.81, right = 2.42, top = 48.91) -->
<!-- get_stamenmap(m, zoom =12, maptype = "toner-lite") %>% ggmap()  -->



<!-- ```{r airbnb-heat} -->
<!-- ggmap(m) + -->
<!--   get_stamenmap(m, zoom =12, maptype = "toner-lite") %>% ggmap() + -->
<!--     geom_polygon(data = airbnb.neigh.for, aes(long, lat, group=group), color="gray80", alpha = .8) + -->
<!--     geom_bin2d(data=airbnb.summ, aes(longitude, latitude)) + -->
<!--     # geom_text(data=airbnb.neigh.cen, aes(long, lat, label=neighbourhood, group=id)) +  -->
<!--     theme_void() -->
<!-- ``` -->

<!-- ### 4. Représenter le nombre de logements par quartier -->

<!-- ```{r} -->
<!-- df = merge( -->
<!--     airbnb.neigh.for, -->
<!--     merge(aggregate(price ~ neighbourhood, airbnb.summ, length), -->
<!--           airbnb.neigh.ord)) -->
<!--   get_stamenmap(m, zoom =12, maptype = "toner-lite") %>% ggmap() + -->
<!--     geom_polygon(data = df,  -->
<!--                  aes(long, lat, group=group, fill=price)) + -->
<!--     # geom_text(data=airbnb.neigh.cen, aes(long, lat, label=neighbourhood, group=id)) +  -->
<!--     labs(fill = "Nombre de logement") + -->
<!--     theme_void() -->
<!-- ``` -->

<!-- ### 5. Idem pour le prix moyen -->

<!-- ```{r} -->
<!-- df = merge( -->
<!--     airbnb.neigh.for, -->
<!--     merge(aggregate(price ~ neighbourhood, airbnb.summ, mean), -->
<!--           airbnb.neigh.ord)) -->
<!--   get_stamenmap(m, zoom =12, maptype = "toner-lite") %>% ggmap() + -->
<!--     geom_polygon(data = df,  -->
<!--                  aes(long, lat, group=group, fill=price)) + -->
<!--     # geom_text(data=airbnb.neigh.cen, aes(long, lat, label=neighbourhood, group=id)) +  -->
<!--     labs(fill = "Prix moyen") + -->
<!--     theme_void() -->
<!-- ``` -->

### Evaluation

A partir du jeu de données de votre choix effectuez des représentations graphiques jolies et pertinentes. Vous commenterez succintement chaque représentation graphique afin d'expliquer ce que vous avez voulu mettre en avant à l'aide de cette dernière.

